-----------------------------------------------------------------------------
--
-- Module      :  Make
-- Copyright   :  (c) 2013-14 Phil Freeman, (c) 2014 Gary Burgess, and other contributors
-- License     :  MIT
--
-- Maintainer  :  Andy Arvanitis
-- Stability   :  experimental
-- Portability :
--
-- |
--
-----------------------------------------------------------------------------

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE PatternGuards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}

module Make
  ( Make(..)
  , runMake
  , buildMakeActions
  ) where

import Control.Monad
import Control.Monad.Error.Class (MonadError(..))
import Control.Monad.Reader

import Data.FileEmbed (embedFile)
import Data.Maybe (fromMaybe)
import Data.Time.Clock
import Data.Version (showVersion)
import qualified Data.Map as M
import qualified Data.ByteString.Char8 as B

import System.Directory (copyFile, doesDirectoryExist, doesFileExist, getModificationTime, createDirectoryIfMissing)
import System.FilePath ((</>), takeDirectory, addExtension, dropExtension)
import System.IO.Error (tryIOError)
import System.IO.UTF8

import Language.PureScript.Errors
import Language.PureScript (Make, runMake)

import qualified Language.PureScript as P
import qualified Language.PureScript.CodeGen.Cpp as CPP
import qualified Language.PureScript.CoreFn as CF
import qualified Paths_purescript as Paths

makeIO :: (IOError -> P.ErrorMessage) -> IO a -> Make a
makeIO f io = do
  e <- liftIO $ tryIOError io
  either (throwError . P.singleError . f) return e

buildMakeActions :: FilePath
                 -> M.Map P.ModuleName (Either P.RebuildPolicy FilePath)
                 -> Bool
                 -> P.MakeActions Make
buildMakeActions outputDir filePathMap usePrefix =
  P.MakeActions getInputTimestamp getOutputTimestamp readExterns codegen progress
  where

  getInputFile :: P.ModuleName -> FilePath
  getInputFile mn =
    let path = fromMaybe (error "Module has no filename in 'make'") $ M.lookup mn filePathMap in
    case path of
      Right path' -> path'
      Left _ -> error  "Module has no filename in 'make'"

  getInputTimestamp :: P.ModuleName -> Make (Either P.RebuildPolicy (Maybe UTCTime))
  getInputTimestamp mn = do
    let path = fromMaybe (error "Module has no filename in 'make'") $ M.lookup mn filePathMap
    let filePath = either (const []) takeDirectory path
        fileBase = filePath </> (last . words . dotsTo ' ' $ P.runModuleName mn)
        sourceFFI = addExtension fileBase sourceExt
        headerFFI = addExtension fileBase headerExt
    e1 <- traverse getTimestamp path
    sffi <- getTimestamp sourceFFI
    hffi <- getTimestamp headerFFI
    return $ fmap (max (max sffi hffi)) e1

  getOutputTimestamp :: P.ModuleName -> Make (Maybe UTCTime)
  getOutputTimestamp mn = do
    let filePath = dotsTo '/' $ P.runModuleName mn
        fileBase = outputDir </> filePath </> (last . words . dotsTo ' ' $ P.runModuleName mn)
        sourceFile = addExtension fileBase sourceExt
        headerFile = addExtension fileBase headerExt
        externsFile = outputDir </> filePath </> "externs.purs"
    foldl min <$> getTimestamp externsFile <*> mapM getTimestamp [sourceFile, headerFile]

  readExterns :: P.ModuleName -> Make (FilePath, P.Externs)
  readExterns mn = do
    let path = outputDir </> (dotsTo '/' $ P.runModuleName mn) </> "externs.purs"
    (path, ) <$> readTextFile path

  codegen :: CF.Module CF.Ann -> P.Environment -> P.Externs -> P.SupplyT Make ()
  codegen m env exts = do
    let mn = CF.moduleName m
    let filePath = dotsTo '/' $ P.runModuleName mn
        fileBase = outputDir </> filePath </> (last . words . dotsTo ' ' $ P.runModuleName mn)
        sourceFile = addExtension fileBase sourceExt
        headerFile = addExtension fileBase headerExt
        externsFile = outputDir </> filePath </> "externs.purs"
        prefix = ["Generated by pcc version " ++ showVersion Paths.version | usePrefix]
    cpps <- CPP.moduleToCpp env m
    let (hdrs,srcs) = span (/= CPP.CppEndOfHeader) cpps
    psrcs <- CPP.prettyPrintCpp <$> pure srcs
    phdrs <- CPP.prettyPrintCpp <$> pure hdrs
    let src = unlines $ map ("// " ++) prefix ++ [psrcs]
        hdr = unlines $ map ("// " ++) prefix ++ [phdrs]

    lift $ do
      writeTextFile sourceFile src
      writeTextFile headerFile hdr
      writeTextFile externsFile exts

      let supportDir = outputDir </> "PureScript"
      supportFilesExist <- dirExists supportDir
      when (not supportFilesExist) $ do
        writeTextFile (supportDir </> "PureScript.hh") $ B.unpack $(embedFile "pcc/include/purescript.hh")
        writeTextFile (supportDir </> "PureScript.cc") $ B.unpack $(embedFile "pcc/include/purescript.cc")
        writeTextFile (supportDir </> "purescript_memory.hh") $ B.unpack $(embedFile "pcc/include/purescript_memory.hh")
        writeTextFile (supportDir </> "purescript_templates.hh") $ B.unpack $(embedFile "pcc/include/purescript_templates.hh")

      let inputPath = dropExtension $ getInputFile mn
          hfile = addExtension inputPath headerExt
          sfile = addExtension inputPath sourceExt
      hfileExists <- textFileExists hfile
      when (hfileExists || requiresForeign m) $ do
        let dstFile = addExtension (fileBase ++ ffiMangle) headerExt
        if hfileExists
          then copyTextFile dstFile hfile
          else writeTextFile dstFile []
      sfileExists <- textFileExists sfile
      when (sfileExists) $ do
        copyTextFile (addExtension (fileBase ++ ffiMangle) sourceExt) sfile

  requiresForeign :: CF.Module a -> Bool
  requiresForeign = not . null . CF.moduleForeign

  dirExists :: FilePath -> Make Bool
  dirExists path = makeIO (const (ErrorMessage [] $ CannotReadFile path)) $ do
    doesDirectoryExist path

  textFileExists :: FilePath -> Make Bool
  textFileExists path = makeIO (const (ErrorMessage [] $ CannotReadFile path)) $ do
    doesFileExist path

  getTimestamp :: FilePath -> Make (Maybe UTCTime)
  getTimestamp path = makeIO (const (ErrorMessage [] $ CannotGetFileInfo path)) $ do
    exists <- doesFileExist path
    traverse (const $ getModificationTime path) $ guard exists

  readTextFile :: FilePath -> Make String
  readTextFile path = makeIO (const (ErrorMessage [] $ CannotReadFile path)) $ readUTF8File path

  copyTextFile :: FilePath -> FilePath -> Make ()
  copyTextFile to from = makeIO (const (ErrorMessage [] $ CannotWriteFile to)) $ do
    createDirectoryIfMissing True (takeDirectory to)
    copyFile from to

  writeTextFile :: FilePath -> String -> Make ()
  writeTextFile path text = makeIO (const (ErrorMessage [] $ CannotWriteFile path)) $ do
    createDirectoryIfMissing True (takeDirectory path)
    _ <- tryIOError $ writeFile path text -- TODO: intended to ignore "file busy", fix properly asap
    return ()

  -- | Render a progress message
  renderProgressMessage :: P.ProgressMessage -> String
  renderProgressMessage (P.CompilingModule mn) = "Compiling " ++ P.runModuleName mn

  progress :: P.ProgressMessage -> Make ()
  progress = liftIO . putStrLn . renderProgressMessage

dotsTo :: Char -> String -> String
dotsTo chr = map (\c -> if c == '.' then chr else c)

headerExt :: String
headerExt = "hh"

sourceExt :: String
sourceExt = "cc"

ffiMangle :: String
ffiMangle = "_ffi"
